// @ts-check

const path = require("path");
const fs = require("fs/promises");

/*
 * What it does?
 * Ensures that /.prisma/client folder is included in Vercel deployment
 *
 * It's modification of official Prisma plugin:
 * https://github.com/prisma/prisma/tree/main/packages/nextjs-monorepo-workaround-plugin
 *
 * It adds record to the nft.json file generated by https://github.com/vercel/nft
 *
 */

class PrismaEnginePlugin {
  constructor(options = {}) {
    this.options = options;
  }

  /**
   * @param {import('webpack').Compiler} compiler
   */
  apply(compiler) {
    const { webpack } = compiler;
    const { Compilation, sources } = webpack;

    const globalPrismaDir = path.join(process.cwd(), "./", ".prisma/client");

    // update nft.json files to include prisma files (only for next.js)
    compiler.hooks.compilation.tap("PrismaPlugin", (compilation) => {
      compilation.hooks.processAssets.tapPromise(
        {
          name: "PrismaPlugin",
          stage: Compilation.PROCESS_ASSETS_STAGE_ANALYSE,
        },
        async (assets) => {
          const engineFilePath = await getEngineFilePath(globalPrismaDir);

          const nftAssetNames = Object.keys(assets).filter((k) =>
            k.endsWith(".nft.json")
          );
          const nftAsyncActions = nftAssetNames.map((assetName) => {
            // prepare paths
            const outputDir = compiler.outputPath;
            const assetPath = path.resolve(outputDir, assetName);
            const assetDir = path.dirname(assetPath);

            // get sources
            const oldSourceAsset = compilation.getAsset(assetName);
            // @ts-ignore
            const oldSourceContents = oldSourceAsset.source.source() + "";
            const ntfLoadedAsJson = JSON.parse(oldSourceContents);

            // !! update sources - include engine file !!
            ntfLoadedAsJson.files.push(path.relative(assetDir, engineFilePath));

            // persist sources
            const newSourceString = JSON.stringify(ntfLoadedAsJson);
            const newRawSource = new sources.RawSource(newSourceString);
            compilation.updateAsset(assetName, newRawSource);
          });

          await Promise.all(nftAsyncActions);
        }
      );
    });
  }
}

async function getEngineFileName(prismaDir) {
  return (await fs.readdir(prismaDir)).filter((file) =>
    file.match(/engine/)
  )[0];
}

async function getEngineFilePath(prismaDir) {
  const fileName = await getEngineFileName(prismaDir);
  return path.join(prismaDir, fileName);
}

module.exports = { PrismaEnginePlugin };
